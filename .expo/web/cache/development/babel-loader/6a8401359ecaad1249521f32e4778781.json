{"ast":null,"code":"import { useLocale } from \"@react-aria/i18n\";\nimport { useLabel } from \"@react-aria/label\";\nimport { usePress, useFocusWithin } from \"@react-aria/interactions\";\nimport { useFocusable, getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { filterDOMProps, mergeProps, useId } from \"@react-aria/utils\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\nvar $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames = new WeakMap();\nexport function useRadio(props, state, ref) {\n  var value = props.value,\n      children = props.children,\n      ariaLabel = props['aria-label'],\n      ariaLabelledby = props['aria-labelledby'];\n  var isDisabled = props.isDisabled || state.isDisabled;\n  var hasChildren = children != null;\n  var hasAriaLabel = ariaLabel != null || ariaLabelledby != null;\n\n  if (!hasChildren && !hasAriaLabel) {\n    console.warn('If you do not provide children, you must specify an aria-label for accessibility');\n  }\n\n  var checked = state.selectedValue === value;\n\n  var onChange = function onChange(e) {\n    e.stopPropagation();\n    state.setSelectedValue(value);\n  };\n\n  var _usePress = usePress({\n    isDisabled: isDisabled\n  }),\n      pressProps = _usePress.pressProps;\n\n  var _useFocusable = useFocusable(mergeProps(props, {\n    onFocus: function onFocus() {\n      return state.setLastFocusedValue(value);\n    }\n  }), ref),\n      focusableProps = _useFocusable.focusableProps;\n\n  var interactions = mergeProps(pressProps, focusableProps);\n  var domProps = filterDOMProps(props, {\n    labelable: true\n  });\n  var tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;\n\n  if (isDisabled) {\n    tabIndex = undefined;\n  }\n\n  return {\n    inputProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({}, interactions, {\n      type: 'radio',\n      name: $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.get(state),\n      tabIndex: tabIndex,\n      disabled: isDisabled,\n      checked: checked,\n      value: value,\n      onChange: onChange\n    }))\n  };\n}\nexport function useRadioGroup(props, state) {\n  var name = props.name,\n      validationState = props.validationState,\n      isReadOnly = props.isReadOnly,\n      isRequired = props.isRequired,\n      isDisabled = props.isDisabled,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? 'vertical' : _props$orientation;\n\n  var _useLocale = useLocale(),\n      direction = _useLocale.direction;\n\n  var _useLabel = useLabel(_babelRuntimeHelpersEsmExtends({}, props, {\n    labelElementType: 'span'\n  })),\n      labelProps = _useLabel.labelProps,\n      fieldProps = _useLabel.fieldProps;\n\n  var domProps = filterDOMProps(props, {\n    labelable: true\n  });\n\n  var _useFocusWithin = useFocusWithin({\n    onBlurWithin: function onBlurWithin() {\n      if (!state.selectedValue) {\n        state.setLastFocusedValue(null);\n      }\n    }\n  }),\n      focusWithinProps = _useFocusWithin.focusWithinProps;\n\n  var onKeyDown = function onKeyDown(e) {\n    var nextDir;\n\n    switch (e.key) {\n      case 'ArrowRight':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'prev';\n        } else {\n          nextDir = 'next';\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'next';\n        } else {\n          nextDir = 'prev';\n        }\n\n        break;\n\n      case 'ArrowDown':\n        nextDir = 'next';\n        break;\n\n      case 'ArrowUp':\n        nextDir = 'prev';\n        break;\n\n      default:\n        return;\n    }\n\n    e.preventDefault();\n    var walker = getFocusableTreeWalker(e.currentTarget, {\n      from: e.target\n    });\n    var nextElem;\n\n    if (nextDir === 'next') {\n      nextElem = walker.nextNode();\n\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.firstChild();\n      }\n    } else {\n      nextElem = walker.previousNode();\n\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.lastChild();\n      }\n    }\n\n    if (nextElem) {\n      nextElem.focus();\n      state.setSelectedValue(nextElem.value);\n    }\n  };\n\n  var groupName = useId(name);\n  $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.set(state, groupName);\n  return {\n    radioGroupProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({\n      role: 'radiogroup',\n      onKeyDown: onKeyDown,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-readonly': isReadOnly || undefined,\n      'aria-required': isRequired || undefined,\n      'aria-disabled': isDisabled || undefined,\n      'aria-orientation': orientation\n    }, fieldProps, focusWithinProps)),\n    labelProps: labelProps\n  };\n}","map":{"version":3,"sources":["packages/@react-aria/radio/src/utils.ts","packages/@react-aria/radio/src/useRadio.ts","packages/@react-aria/radio/src/useRadioGroup.ts"],"names":["radioGroupNames","ariaLabelledby","isDisabled","props","state","hasChildren","children","hasAriaLabel","ariaLabel","console","checked","onChange","e","pressProps","usePress","focusableProps","useFocusable","mergeProps","onFocus","interactions","domProps","filterDOMProps","labelable","tabIndex","inputProps","type","name","disabled","value","orientation","direction","useLocale","fieldProps","useLabel","labelElementType","focusWithinProps","useFocusWithin","onBlurWithin","onKeyDown","nextDir","walker","getFocusableTreeWalker","from","target","nextElem","groupName","useId","radioGroupProps","role","validationState","isReadOnly","isRequired","labelProps"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RadioGroupState} from '@react-stately/radio';\n\nexport const radioGroupNames = new WeakMap<RadioGroupState, string>();\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaRadioProps} from '@react-types/radio';\nimport {filterDOMProps, mergeProps} from '@react-aria/utils';\nimport {InputHTMLAttributes, RefObject} from 'react';\nimport {radioGroupNames} from './utils';\nimport {RadioGroupState} from '@react-stately/radio';\nimport {useFocusable} from '@react-aria/focus';\nimport {usePress} from '@react-aria/interactions';\n\ninterface RadioAria {\n  /** Props for the input element. */\n  inputProps: InputHTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for an individual\n * radio button in a radio group.\n * @param props - Props for the radio.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n * @param ref - Ref to the HTML input element.\n */\nexport function useRadio(props: AriaRadioProps, state: RadioGroupState, ref: RefObject<HTMLElement>): RadioAria {\n  let {\n    value,\n    children,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby\n  } = props;\n\n  const isDisabled = props.isDisabled || state.isDisabled;\n\n  let hasChildren = children != null;\n  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;\n  if (!hasChildren && !hasAriaLabel) {\n    console.warn('If you do not provide children, you must specify an aria-label for accessibility');\n  }\n\n  let checked = state.selectedValue === value;\n\n  let onChange = (e) => {\n    e.stopPropagation();\n    state.setSelectedValue(value);\n  };\n\n  let {pressProps} = usePress({\n    isDisabled\n  });\n\n  let {focusableProps} = useFocusable(mergeProps(props, {\n    onFocus: () => state.setLastFocusedValue(value)\n  }), ref);\n  let interactions = mergeProps(pressProps, focusableProps);\n  let domProps = filterDOMProps(props, {labelable: true});\n  let tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;\n  if (isDisabled) {\n    tabIndex = undefined;\n  }\n\n  return {\n    inputProps: mergeProps(domProps, {\n      ...interactions,\n      type: 'radio',\n      name: radioGroupNames.get(state),\n      tabIndex,\n      disabled: isDisabled,\n      checked,\n      value,\n      onChange\n    })\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaRadioGroupProps} from '@react-types/radio';\nimport {filterDOMProps, mergeProps, useId} from '@react-aria/utils';\nimport {getFocusableTreeWalker} from '@react-aria/focus';\nimport {HTMLAttributes} from 'react';\nimport {radioGroupNames} from './utils';\nimport {RadioGroupState} from '@react-stately/radio';\nimport {useFocusWithin} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\ninterface RadioGroupAria {\n  /** Props for the radio group wrapper element. */\n  radioGroupProps: HTMLAttributes<HTMLElement>,\n  /** Props for the radio group's visible label (if any). */\n  labelProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a radio group component.\n * Radio groups allow users to select a single item from a list of mutually exclusive options.\n * @param props - Props for the radio group.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n */\nexport function useRadioGroup(props: AriaRadioGroupProps, state: RadioGroupState): RadioGroupAria {\n  let {\n    name,\n    validationState,\n    isReadOnly,\n    isRequired,\n    isDisabled,\n    orientation = 'vertical'\n  } = props;\n  let {direction} = useLocale();\n\n  let {labelProps, fieldProps} = useLabel({\n    ...props,\n    // Radio group is not an HTML input element so it\n    // shouldn't be labeled by a <label> element.\n    labelElementType: 'span'\n  });\n\n  let domProps = filterDOMProps(props, {labelable: true});\n\n  // When the radio group loses focus, reset the focusable radio to null if\n  // there is no selection. This allows tabbing into the group from either\n  // direction to go to the first or last radio.\n  let {focusWithinProps} = useFocusWithin({\n    onBlurWithin() {\n      if (!state.selectedValue) {\n        state.setLastFocusedValue(null);\n      }\n    }\n  });\n\n  let onKeyDown = (e) => {\n    let nextDir;\n    switch (e.key) {\n      case 'ArrowRight':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'prev';\n        } else {\n          nextDir = 'next';\n        }\n        break;\n      case 'ArrowLeft':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'next';\n        } else {\n          nextDir = 'prev';\n        }\n        break;\n      case 'ArrowDown':\n        nextDir = 'next';\n        break;\n      case 'ArrowUp':\n        nextDir = 'prev';\n        break;\n      default:\n        return;\n    }\n    e.preventDefault();\n    let walker = getFocusableTreeWalker(e.currentTarget, {from: e.target});\n    let nextElem;\n    if (nextDir === 'next') {\n      nextElem = walker.nextNode();\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.firstChild();\n      }\n    } else {\n      nextElem = walker.previousNode();\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.lastChild();\n      }\n    }\n    if (nextElem) {\n      // Call focus on nextElem so that keyboard navigation scrolls the radio into view\n      nextElem.focus();\n      state.setSelectedValue(nextElem.value);\n    }\n  };\n\n  let groupName = useId(name);\n  radioGroupNames.set(state, groupName);\n\n  return {\n    radioGroupProps: mergeProps(domProps, {\n      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup\n      role: 'radiogroup',\n      onKeyDown,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-readonly': isReadOnly || undefined,\n      'aria-required': isRequired || undefined,\n      'aria-disabled': isDisabled || undefined,\n      'aria-orientation': orientation,\n      ...fieldProps,\n      ...focusWithinProps\n    }),\n    labelProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}