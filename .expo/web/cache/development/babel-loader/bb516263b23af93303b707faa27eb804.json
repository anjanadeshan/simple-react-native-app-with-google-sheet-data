{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { useLongPress, usePress } from \"@react-aria/interactions\";\nimport { useLocale, useCollator } from \"@react-aria/i18n\";\nimport { focusWithoutScrolling, mergeProps, scrollIntoView, useEvent, isAppleDevice, isMac } from \"@react-aria/utils\";\nimport { focusSafely, getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { useEffect, useRef, useMemo } from \"react\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\n\nfunction $d9657c365c2f735bcaf048eee8599a4a$export$isNonContiguousSelectionModifier(e) {\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nfunction $d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n\nexport function useTypeSelect(options) {\n  var keyboardDelegate = options.keyboardDelegate,\n      selectionManager = options.selectionManager,\n      onTypeSelect = options.onTypeSelect;\n  var state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  var onKeyDown = function onKeyDown(e) {\n    var character = $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(e.key);\n\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n    var key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(key) {\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n\nexport function useSelectableCollection(options) {\n  var manager = options.selectionManager,\n      delegate = options.keyboardDelegate,\n      ref = options.ref,\n      _options$autoFocus = options.autoFocus,\n      autoFocus = _options$autoFocus === void 0 ? false : _options$autoFocus,\n      _options$shouldFocusW = options.shouldFocusWrap,\n      shouldFocusWrap = _options$shouldFocusW === void 0 ? false : _options$shouldFocusW,\n      _options$disallowEmpt = options.disallowEmptySelection,\n      disallowEmptySelection = _options$disallowEmpt === void 0 ? false : _options$disallowEmpt,\n      _options$disallowSele = options.disallowSelectAll,\n      disallowSelectAll = _options$disallowSele === void 0 ? false : _options$disallowSele,\n      _options$selectOnFocu = options.selectOnFocus,\n      selectOnFocus = _options$selectOnFocu === void 0 ? manager.selectionBehavior === 'replace' : _options$selectOnFocu,\n      _options$disallowType = options.disallowTypeAhead,\n      disallowTypeAhead = _options$disallowType === void 0 ? false : _options$disallowType,\n      shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n      _options$allowsTabNav = options.allowsTabNavigation,\n      allowsTabNavigation = _options$allowsTabNav === void 0 ? false : _options$allowsTabNav,\n      isVirtualized = options.isVirtualized,\n      _options$scrollRef = options.scrollRef,\n      scrollRef = _options$scrollRef === void 0 ? ref : _options$scrollRef;\n\n  var _useLocale = useLocale(),\n      direction = _useLocale.direction;\n\n  var onKeyDown = function onKeyDown(e) {\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    if (!ref.current.contains(e.target)) {\n      return;\n    }\n\n    var navigateToKey = function navigateToKey(key, childFocus) {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !$d9657c365c2f735bcaf048eee8599a4a$export$isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown':\n        {\n          if (delegate.getKeyBelow) {\n            e.preventDefault();\n            var nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : delegate.getFirstKey == null ? void 0 : delegate.getFirstKey();\n\n            if (nextKey == null && shouldFocusWrap) {\n              nextKey = delegate.getFirstKey == null ? void 0 : delegate.getFirstKey(manager.focusedKey);\n            }\n\n            navigateToKey(nextKey);\n          }\n\n          break;\n        }\n\n      case 'ArrowUp':\n        {\n          if (delegate.getKeyAbove) {\n            e.preventDefault();\n\n            var _nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : delegate.getLastKey == null ? void 0 : delegate.getLastKey();\n\n            if (_nextKey == null && shouldFocusWrap) {\n              _nextKey = delegate.getLastKey == null ? void 0 : delegate.getLastKey(manager.focusedKey);\n            }\n\n            navigateToKey(_nextKey);\n          }\n\n          break;\n        }\n\n      case 'ArrowLeft':\n        {\n          if (delegate.getKeyLeftOf) {\n            e.preventDefault();\n\n            var _nextKey2 = delegate.getKeyLeftOf(manager.focusedKey);\n\n            navigateToKey(_nextKey2, direction === 'rtl' ? 'first' : 'last');\n          }\n\n          break;\n        }\n\n      case 'ArrowRight':\n        {\n          if (delegate.getKeyRightOf) {\n            e.preventDefault();\n\n            var _nextKey3 = delegate.getKeyRightOf(manager.focusedKey);\n\n            navigateToKey(_nextKey3, direction === 'rtl' ? 'last' : 'first');\n          }\n\n          break;\n        }\n\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          var firstKey = delegate.getFirstKey(manager.focusedKey, $d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n\n          if ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n\n        break;\n\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          var lastKey = delegate.getLastKey(manager.focusedKey, $d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n\n          if ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n\n        break;\n\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n\n          var _nextKey4 = delegate.getKeyPageBelow(manager.focusedKey);\n\n          navigateToKey(_nextKey4);\n        }\n\n        break;\n\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n\n          var _nextKey5 = delegate.getKeyPageAbove(manager.focusedKey);\n\n          navigateToKey(_nextKey5);\n        }\n\n        break;\n\n      case 'a':\n        if ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n\n        break;\n\n      case 'Escape':\n        e.preventDefault();\n\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n\n        break;\n\n      case 'Tab':\n        {\n          if (!allowsTabNavigation) {\n            if (e.shiftKey) {\n              ref.current.focus();\n            } else {\n              var walker = getFocusableTreeWalker(ref.current, {\n                tabbable: true\n              });\n              var next;\n              var last;\n\n              do {\n                last = walker.lastChild();\n\n                if (last) {\n                  next = last;\n                }\n              } while (last);\n\n              if (next && !next.contains(document.activeElement)) {\n                focusWithoutScrolling(next);\n              }\n            }\n\n            break;\n          }\n        }\n    }\n  };\n\n  var scrollPos = useRef({\n    top: 0,\n    left: 0\n  });\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : function () {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  var onFocus = function onFocus(e) {\n    if (manager.isFocused) {\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      var navigateToFirstKey = function navigateToFirstKey(key) {\n        if (key != null) {\n          manager.setFocusedKey(key);\n\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n\n      var relatedTarget = e.relatedTarget;\n\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {\n        var _manager$lastSelected;\n\n        navigateToFirstKey((_manager$lastSelected = manager.lastSelectedKey) != null ? _manager$lastSelected : delegate.getLastKey());\n      } else {\n        var _manager$firstSelecte;\n\n        navigateToFirstKey((_manager$firstSelecte = manager.firstSelectedKey) != null ? _manager$firstSelecte : delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\" + manager.focusedKey + \"\\\"]\");\n\n      if (element) {\n        focusWithoutScrolling(element);\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  var onBlur = function onBlur(e) {\n    if (!e.currentTarget.contains(e.relatedTarget)) {\n      manager.setFocused(false);\n    }\n  };\n\n  var autoFocusRef = useRef(autoFocus);\n  useEffect(function () {\n    if (autoFocusRef.current) {\n      var focusedKey = null;\n\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      }\n\n      if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      var selectedKeys = manager.selectedKeys;\n\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n\n    autoFocusRef.current = false;\n  }, []);\n  useEffect(function () {\n    if (!isVirtualized && manager.focusedKey && scrollRef != null && scrollRef.current) {\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\" + manager.focusedKey + \"\\\"]\");\n\n      if (element) {\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n  var handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown: function onMouseDown(e) {\n      if (e.currentTarget.contains(e.target)) {\n        e.preventDefault();\n      }\n    }\n  };\n\n  var _useTypeSelect = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  }),\n      typeSelectProps = _useTypeSelect.typeSelectProps;\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  var tabIndex;\n\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: _babelRuntimeHelpersEsmExtends({}, handlers, {\n      tabIndex: tabIndex\n    })\n  };\n}\nexport function useSelectableItem(options) {\n  var manager = options.selectionManager,\n      key = options.key,\n      ref = options.ref,\n      shouldSelectOnPressUp = options.shouldSelectOnPressUp,\n      isVirtualized = options.isVirtualized,\n      shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n      focus = options.focus,\n      isDisabled = options.isDisabled,\n      onAction = options.onAction;\n\n  var onSelect = function onSelect(e) {\n    if (e.pointerType === 'keyboard' && $d9657c365c2f735bcaf048eee8599a4a$export$isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || e && ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual')) {\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  var isFocused = key === manager.focusedKey;\n  useEffect(function () {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  var itemProps = {};\n\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: isFocused ? 0 : -1,\n      onFocus: function onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n  var modality = useRef(null);\n  var hasPrimaryAction = onAction && manager.selectionMode === 'none';\n  var hasSecondaryAction = onAction && manager.selectionMode !== 'none' && manager.selectionBehavior === 'replace';\n  var allowsSelection = !isDisabled && manager.canSelectItem(key);\n  var itemPressProps = {};\n\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n\n      if (e.pointerType === 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPressUp = function (e) {\n      if (e.pointerType !== 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = hasPrimaryAction ? function () {\n      return onAction();\n    } : null;\n  } else {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n\n      if (e.pointerType !== 'touch' && e.pointerType !== 'virtual') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = function (e) {\n      if (e.pointerType === 'touch' || e.pointerType === 'virtual' || hasPrimaryAction) {\n        if (hasPrimaryAction || hasSecondaryAction) {\n          onAction();\n        } else {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n\n  var _usePress = usePress(itemPressProps),\n      pressProps = _usePress.pressProps,\n      isPressed = _usePress.isPressed;\n\n  var onDoubleClick = hasSecondaryAction ? function (e) {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  var _useLongPress = useLongPress({\n    isDisabled: !hasSecondaryAction,\n    onLongPress: function onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  }),\n      longPressProps = _useLongPress.longPressProps;\n\n  var onKeyUp = hasSecondaryAction ? function (e) {\n    if (e.key === 'Enter') {\n      onAction();\n    }\n  } : undefined;\n  return {\n    itemProps: mergeProps(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, hasSecondaryAction ? longPressProps : {}, {\n      onKeyUp: onKeyUp,\n      onDoubleClick: onDoubleClick\n    }),\n    isPressed: isPressed\n  };\n}\nexport var ListKeyboardDelegate = function () {\n  function ListKeyboardDelegate(collection, disabledKeys, ref, collator) {\n    _classCallCheck(this, ListKeyboardDelegate);\n\n    this.collection = void 0;\n    this.disabledKeys = void 0;\n    this.ref = void 0;\n    this.collator = void 0;\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  _createClass(ListKeyboardDelegate, [{\n    key: \"getKeyBelow\",\n    value: function getKeyBelow(key) {\n      key = this.collection.getKeyAfter(key);\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getKeyAbove\",\n    value: function getKeyAbove(key) {\n      key = this.collection.getKeyBefore(key);\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getFirstKey\",\n    value: function getFirstKey() {\n      var key = this.collection.getFirstKey();\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getLastKey\",\n    value: function getLastKey() {\n      var key = this.collection.getLastKey();\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.ref.current.querySelector(\"[data-key=\\\"\" + key + \"\\\"]\");\n    }\n  }, {\n    key: \"getKeyPageAbove\",\n    value: function getKeyPageAbove(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n\n      if (!item) {\n        return null;\n      }\n\n      var pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n      while (item && item.offsetTop > pageY) {\n        key = this.getKeyAbove(key);\n        item = this.getItem(key);\n      }\n\n      return key;\n    }\n  }, {\n    key: \"getKeyPageBelow\",\n    value: function getKeyPageBelow(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n\n      if (!item) {\n        return null;\n      }\n\n      var pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n      while (item && item.offsetTop < pageY) {\n        key = this.getKeyBelow(key);\n        item = this.getItem(key);\n      }\n\n      return key;\n    }\n  }, {\n    key: \"getKeyForSearch\",\n    value: function getKeyForSearch(search, fromKey) {\n      if (!this.collator) {\n        return null;\n      }\n\n      var collection = this.collection;\n      var key = fromKey || this.getFirstKey();\n\n      while (key != null) {\n        var item = collection.getItem(key);\n        var substring = item.textValue.slice(0, search.length);\n\n        if (item.textValue && this.collator.compare(substring, search) === 0) {\n          return key;\n        }\n\n        key = this.getKeyBelow(key);\n      }\n\n      return null;\n    }\n  }]);\n\n  return ListKeyboardDelegate;\n}();\nexport function useSelectableList(props) {\n  var selectionManager = props.selectionManager,\n      collection = props.collection,\n      disabledKeys = props.disabledKeys,\n      ref = props.ref,\n      keyboardDelegate = props.keyboardDelegate,\n      autoFocus = props.autoFocus,\n      shouldFocusWrap = props.shouldFocusWrap,\n      isVirtualized = props.isVirtualized,\n      disallowEmptySelection = props.disallowEmptySelection,\n      _props$selectOnFocus = props.selectOnFocus,\n      selectOnFocus = _props$selectOnFocus === void 0 ? false : _props$selectOnFocus,\n      disallowTypeAhead = props.disallowTypeAhead,\n      shouldUseVirtualFocus = props.shouldUseVirtualFocus,\n      allowsTabNavigation = props.allowsTabNavigation;\n  var collator = useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  var delegate = useMemo(function () {\n    return keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator);\n  }, [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  var _useSelectableCollect = useSelectableCollection({\n    ref: ref,\n    selectionManager: selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus: autoFocus,\n    shouldFocusWrap: shouldFocusWrap,\n    disallowEmptySelection: disallowEmptySelection,\n    selectOnFocus: selectOnFocus,\n    disallowTypeAhead: disallowTypeAhead,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation: allowsTabNavigation,\n    isVirtualized: isVirtualized,\n    scrollRef: ref\n  }),\n      collectionProps = _useSelectableCollect.collectionProps;\n\n  return {\n    listProps: collectionProps\n  };\n}","map":{"version":3,"sources":["packages/@react-aria/selection/src/utils.ts","packages/@react-aria/selection/src/useTypeSelect.ts","packages/@react-aria/selection/src/useSelectableCollection.ts","packages/@react-aria/selection/src/useSelectableItem.ts","packages/@react-aria/selection/src/ListKeyboardDelegate.ts","packages/@react-aria/selection/src/useSelectableList.ts"],"names":["isAppleDevice","e","isMac","onTypeSelect","state","search","timeout","onKeyDown","character","getStringForKey","key","keyboardDelegate","selectionManager","clearTimeout","setTimeout","typeSelectProps","onKeyDownCapture","autoFocus","shouldFocusWrap","disallowEmptySelection","disallowSelectAll","selectOnFocus","manager","disallowTypeAhead","allowsTabNavigation","scrollRef","ref","direction","useLocale","navigateToKey","delegate","nextKey","firstKey","lastKey","walker","getFocusableTreeWalker","tabbable","last","next","document","focusWithoutScrolling","scrollPos","useRef","top","left","useEvent","isVirtualized","scrollLeft","onFocus","navigateToFirstKey","relatedTarget","Node","element","scrollIntoView","onBlur","autoFocusRef","useEffect","focusedKey","selectedKeys","focusSafely","handlers","onMouseDown","mergeProps","tabIndex","collectionProps","onAction","onSelect","isFocused","focus","itemProps","modality","hasPrimaryAction","hasSecondaryAction","allowsSelection","itemPressProps","isPressed","usePress","onDoubleClick","longPressProps","useLongPress","isDisabled","onLongPress","onKeyUp","collection","disabledKeys","collator","constructor","getKeyBelow","item","getKeyAbove","getFirstKey","getLastKey","getKeyPageAbove","menu","pageY","Math","getKeyPageBelow","getKeyForSearch","fromKey","substring","useCollator","usage","sensitivity","useMemo","shouldUseVirtualFocus","listProps"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice} from '@react-aria/utils';\nimport {isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, Key, KeyboardEvent, useRef} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\ninterface TypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\ninterface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: TypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent, HTMLAttributes, Key, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, useEvent} from '@react-aria/utils';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\ninterface SelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>\n}\n\ninterface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: SelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {direction} = useLocale();\n\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: HTMLElement;\n            let last: HTMLElement;\n            do {\n              last = walker.lastChild() as HTMLElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        focusWithoutScrolling(element);\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n    autoFocusRef.current = false;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && manager.focusedKey && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (e.currentTarget.contains(e.target)) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusSafely} from '@react-aria/focus';\nimport {HTMLAttributes, Key, RefObject, useEffect, useRef} from 'react';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {LongPressEvent, PressEvent} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\n\ninterface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the cell. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void\n}\n\ninterface SelectableItemAria {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: HTMLAttributes<HTMLElement>,\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction\n  } = options;\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  let isFocused = key === manager.focusedKey;\n  useEffect(() => {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: isFocused ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n  let modality = useRef(null);\n  let hasPrimaryAction = onAction && manager.selectionMode === 'none';\n  let hasSecondaryAction = onAction && manager.selectionMode !== 'none' && manager.selectionBehavior === 'replace';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      if (e.pointerType === 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPressUp = (e) => {\n      if (e.pointerType !== 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n  } else {\n    // On touch, it feels strange to select on touch down, so we special case this.\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      if (e.pointerType !== 'touch' && e.pointerType !== 'virtual') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      if (e.pointerType === 'touch' || e.pointerType === 'virtual' || hasPrimaryAction) {\n        // Single tap on touch with selectionBehavior = 'replace' performs an action, i.e. navigation.\n        // Also perform action on press up when selectionMode = 'none'.\n        if (hasPrimaryAction || hasSecondaryAction) {\n          onAction();\n        } else {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  // TODO: what about when drag and drop is also enabled??\n  let {longPressProps} = useLongPress({\n    isDisabled: !hasSecondaryAction,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Pressing the Enter key with selectionBehavior = 'replace' performs an action (i.e. navigation).\n  let onKeyUp = hasSecondaryAction ? (e: KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      onAction();\n    }\n  } : undefined;\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      hasSecondaryAction ? longPressProps : {},\n      {onKeyUp, onDoubleClick}\n    ),\n    isPressed\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {HTMLAttributes, Key, RefObject, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\ninterface SelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\ninterface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: SelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n    isVirtualized,\n    scrollRef: ref\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}